/*
    Time Complexity: O(N*100000), Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) 
    But mathematically its not possible to generate all number between 0 to 10^5 its way lesser than 10^5.
    N = size of the array with numbers of which each node could be multiplied.
    Problem Link: https://www.geeksforgeeks.org/problems/minimum-multiplications-to-reach-end/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=minimum-multiplications-to-reach-end
*/

class Pair{
    int first, second;
    public Pair(int f, int s){
        first = f;
        second = s;
    }
}

class Solution {
    int minimumMultiplications(int[] arr, int start, int end) {
        if(start == end) return 0;
        int n = arr.length;
        Queue<Pair> q = new LinkedList<Pair>();
        q.add(new Pair(0, start));
        
        int dist[] = new int[100000];
        
        Arrays.fill(dist, (int)(1e9));
        dist[start] = 0;
        
        while(!q.isEmpty()){
            
            Pair p = q.peek();
            int steps = p.first;
            int node = p.second;
            q.remove();
            
            for(int i = 0; i < n; i++){
                
                int newNode = (arr[i] * node) % 100000;
                
                if(steps + 1 < dist[newNode]){
                    dist[newNode] = steps + 1;
                    if(newNode == end){
                        return steps + 1;
                    }
                    q.add(new Pair(steps + 1, newNode));
                }
            }
        }
        
        return -1;
    }
}
